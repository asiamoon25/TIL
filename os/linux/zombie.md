# Zombie

## 좀비 프로세스

***

### 개요

영화 속 좀비는 몸에 총을 맞아도 죽지않는 불사의 존재이다. 이 개념은 리눅스 프로세스에도 전해지는데 흔히 말하는 종료 kill -15 => SIGTERM 이 먹지 않는 상태의 프로세스를 말한다.

### 왜? 발생?

서버 스펙을 상회하는 작업이 돌아가거나 부모 프로세스가 받아들이지 못할정도의 많은 양의 작업이 돌아가는 경우라고 생각된다.

_**부모프로세스** : 좀비 프로세스가 되기 전 부모 프로세스가 fork() 함수를 통해 자식 프로세스가 프로그램을 동작할 수 있도록 공간을 만들어주는 프로세스_

### 확인 방법

top과 ps 명령어로 찾아볼 수 있다.

```
top -b -n 1 | grep zombie

Tasks: 151 total,   1 running, 150 sleeping,   0 stopped,   0 zombie
```

```
ps -ef |grep defunct | grep -v grep


root     17107 21899  0 Feb25 ?        00:00:00 [myagent] <defunct>
testuser 21207 21205  0 Feb26 ?        00:00:00 [check_service.sh] <defunct>
```

### 궁금한점

kill -9 PID를 쓰면 되지 않나

여태껏 프로세스를 죽일 때 죽지 않으면 kill -9 명령어를 사용하여 죽여왔지만 그건 아직 좀비 프로세스가 아니기 때문에 kill 이 되는 경우이다.

이걸 설명하려면 프로세스의 종료 과정이 필요한데 프로세스가 종료될 때 마지막 문장의 실행을 끝내고, exit() 시스템 호출을 사용하여 운영체제가 자신의 삭제를 요청하면서 종료되는 과정이 있다.

\
이 때, 프로세스는 자신의 부모 프로세스가 호출한 wait() 을 통해 상태값을 반환 및 프로세스의 남은 자원들이 운영체제로 돌아가게 된다.(모든건 죽어서 자연으로..)

\
부모프로세스는 wait() 호출을 사용해 자식 프로세스가 죽을 때까지 기다릴 수 있고 부모가 자기의 종료상태를 얻어 낼 수 있도록 하나의 인자를 전달받는다.&#x20;

이 인자는 부모가 어떤 자식이 종료 되었는지 파악할 수 있도록 자식의 프로세스 식별자를 반환한다.

이렇게 되면 프로세스의 종료 상태가 저장되는 프로세스 테이블의 해당 항목(식별자)는 부모 프로세스가 wait() 을 호출할때까지 남아있게 된다.

이렇게 되면 종료는 되었지만 부모프로세스가 wait()을 호출하지 않은 프로세스가 즉, 좀비가 된다.

```
모든 프로세스는 종료하게 되면, 좀비 상태가 되지만 아주 짧은 시간 동안 머무르게 되고,

부모가 wait()를 호출하면 좀비 프로세스의 프로세스 식별자와 프로세스 테이블의 해당 항목이 운영체제에게 반환된다.
```

이러한 과정으로 kill -9 이 먹질 않는다.

### 해결방법

간단하다. 부모 프로세스까지 죽이면된다.

```
ps -ef |grep defunct | grep -v grep


root     17107 21899  0 Feb25 ?        00:00:00 [myagent] <defunct>
happytuk 21207 21205  0 Feb26 ?        00:00:00 [check_service.sh] <defunct>  => 좀비 프로세스
```

## 고아 프로세스

***

좀비 프로세스와 비스무리하다.

고아 프로세스는 부모 프로세스가 wait() 을 호출하는 대신에 그냥 종료해버리는 것이다. 이러한 상황에 처한 자식 프로세스를 고아 프로세스라고 한다.

SIGTERM 신호가 가서 부모가 wait() 을 호출 되기전에 부모가 종료되는 상황....

이 경우에는 고아프로세스의 새로운 부모 프로세스로 init 프로세스를 지정하면 된다.

init 프로세스는 주기적으로 wait() 을 콜하여 고아프로세스의 종료 상태를 수집하고 프로세스 식별자와 프로세스 테이블 항목을 반환한다.
