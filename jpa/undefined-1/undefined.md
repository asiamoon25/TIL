# 격리수준

## 격리 수준(Isolation Level) 이란?

* 트랜잭션끼리 **얼마나 서로 고립되어 있는지 나타내는 수준**
* 한 트랜잭션이 **다른 트랜잭션이 변경한 데이터 에 대한 접근 강도를 의미함.**

Level 이 높아질 수록 트랜잭션간 고립정도가 높아지며, 성능저하도 야기됨



일반적인 온라인 서비스에서는  READ COMMITTED 나 REPEATABLE READ 중 하나를 사용함.

<table><thead><tr><th width="131"></th><th width="176">DIRTY READ</th><th>NON-REPEATABLE READ</th><th>PHANTOM READ</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>발생</td><td>발생</td><td>발생</td></tr><tr><td>READ COMMITTED</td><td>발생하지 않음</td><td>발생</td><td>발생</td></tr><tr><td>REPEATABLE READ</td><td>발생하지 않음</td><td>발생하지 않음</td><td>발생</td></tr><tr><td>SERIALIZABLE</td><td>발생하지 않음</td><td>발생하지 않음</td><td>발생하지 않음</td></tr></tbody></table>



### Lock

데이터베이스에서 Lock 은 데이터를 보호하기 위해 특정 데이터 항목에 대한 접근을 제한하는 메커니즘.&#x20;

Lock 을 사용함으로써 동시에 여러 트랜잭션이 같은 데이터에 접근할 때 발생할 수 있는 문제들을 방지할 수 있음(dirty read, phantom read , non-repeatable read, 논리적  일관성  없음)



### 트랜잭션의 격리 수준과 Lock

1.  READ UNCOMMITTED(읽기 미확정)&#x20;



    &#x20;한 트랜잭션이 변경했지만 아직 커밋하지 않은 데이터를 다른 트랜잭션이 읽을 수 있음.&#x20;

    :fast\_forward: 이로 인해 더티 리드가 발생할 수 있음. 여기서는 거의 Lock 이사용되지 않음.

    \
    ex) A가 은행 계좌에 $100 을 가지고 있음. A가 $100을 더 입금하는 트랜잭션이 진행중임.\
    :fast\_forward: B라는 사람이 A의 계좌 잔액을 조회할 때, 입금 트랜잭션이 아직 커밋되지 않았음에도 불구하고 $200 을 보게됨. A의 입금 트랜잭션이 실패하거나 취소 된다면, B는 잘못된 정보를 보게된거임.


2.  Read Committed(읽기 확정)&#x20;



    대부분의 DB 시스템의 기본 격리 수준.&#x20;

    한 트랜잭션이 커밋하여 확정된 데이터만 다른 트랜잭션에서 읽을 수 있음.&#x20;

    이 수준에서는 '논리적 일관성 없는 데이터' 를 방지하지만 반복 불가능한 읽기는 여전히 가능함. Lock 은 데이터를 읽거나 쓸 때 짧은 시간 동안만 유지됨.\
    \
    ex) A가 은행 계좌 잔액이 $100임. A가 $100 을 더 입금하는 트랜잭션이 커밋되었음.\
    B가 A 의 계좌를 조회하여 $200을 본 후, 다른 트랜잭션에서 A가 $50 을 출금함.\
    B가 다시 A의 계좌를 조회하면 이번에는 $150 을 보게 됨. 같은 조회 작업을 반복했는데도 결과가 달라짐.


3.  Repeatable Read(반복 가능한 읽기)



    한 트랜잭션 내에서 조회한 데이터를 반복해서 읽어도 처음과 동일한 데이터를 보장함.

    조회된 모든 데이터에 대해 Lock 이 유지되며, 다른 트랜잭션이 해당 데이터를 수정할 수 없음.

    그러나 Phantom read 는 발생할 수 있음.\
    \
    ex) A 의 계좌 잔액이 $100 임. B가 A의 잔액을 조회함.\
    B가 A의 계좌 잔액을 조회하는 동안, 다른 트랜잭션에서 A의 계좌에 $50을 입금함. B가 계좌의 거래 내역을 다시 조회할 때, 처음 조회했을 때 없던 새로운 거래(팬텀) 가 나타남.


4.  Serializable(직렬화 가능)



    가장 엄격한 격리수준, 트랜잭션들이 순차적으로 실행되는 것처럼 동작함. 이 수준에서는 팬텀리드 까지 방지함. 하지만 Lock 을 많이 사용하기 때문에 동시성이 크게 떨어질 수 있음\
    \
    ex) 순차적으로 실행되는 것처럼 처리됨.\
    B가 A의 계좌 잔액을 조회하는 동안 다른 어떤 트랜잭션도 그 계좌에 접근할 수 없음. 데이터의 일관성은 보장하지만, 동시성이 크게 제한되어 성능 저하가 발생할 수 있음.

:question: **2, 3 은 멀쩡해 보이는데...**

#### Read Committed

이게문제가 되는 이유는 데이터의 일관성과 예측 가능성을 보장하기 어렵기 때문임.

금융 시스템에서 동일한 트랜잭션 내에서 여러 번의 잔액 조회를 수행하는 경우, 첫 번째 조회화 두 번째 조회 사이에 다른 사용자의 트랜잭션이 잔액을 변경했다면 두 조회 결과가 다를 수 있음.

:fast\_forward: 비즈니스 로직 오류 : 잔액을 기반으로 결정을 내려야 하는 로직이 있다면, 변경된 데이터로 인해 잘못된 결정을 내릴 수 있음.

:fast\_forward: 사용자 경험 저하 : 사용자가 동일한 조건에서 데이터를 조회했을 때 결과가 계속 달라진다면 혼란스럽고, 시스템에 대한 신뢰를 잃을 수 있음.



#### Phantom Read

범위 조회의 결과가 한 트랜잭션 내에서 일관되지 않을 때 발생함.

특히 범위 쿼리를 사용하여 데이터 세트를 처리할 때 중요한 부분인데, 처음 조회했을 때 없던 데이터가 나중에 조회 했을 때 갑자기 나타날 수 있기 때문..

:fast\_forward: 데이터 무결성 위반 : 특정 조건을 만족하는 데잍터 세트에 대해 작업을 수행하는 경우, 작업 시작 후에 새로운 데이터가 추가되어 원래 작업 의도와 다른 결과를 초래할 수 있음.

:fast\_forward:결과의 예측 불가능성: 보고서 생성 또는 배치 처리 작업에서 동일한 쿼리를 반복해서 실행하는 경우 ,팬텀 데이터로 인해 결과가 예측 불가능하게 됨.
